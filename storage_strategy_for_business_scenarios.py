# -*- coding: utf-8 -*-
"""Storage Strategy for Business Scenarios.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1C8zIWVKhe9cjjjYCuo0IVeBefLvxiWdb
"""

'''
Analyze Each Scenario (40 mins)
For each of the 5 scenarios:

Identify key requirements

Data structure needs
Query patterns
Consistency requirements
Scalability needs
Performance requirements
Evaluate storage options

Consider RDBMS, document store, wide-column, graph, key-value
Match requirements to storage capabilities
Identify trade-offs
Make a recommendation

Choose the most suitable storage type
Justify your choice clearly
Acknowledge any trade-offs

ANS - Scenario 1: Core Banking Transaction System
Recommended Storage Type: RDBMS (e.g., PostgreSQL, Oracle, SQL Server)

Justification:

Data Structure: Highly structured tables (Accounts, Transactions, Customers) with strict relationships.

Query Patterns: Complex joins are required to calculate balances and generate audit trails.

Consistency: ACID compliance is non-negotiable. Transactions must be Atomic (all or nothing) and Consistent to prevent "double-spending" or lost data.

Scalability: While RDBMS is harder to scale horizontally than NoSQL, modern "NewSQL" or partitioned RDBMS can handle high volumes while maintaining the relational integrity required for compliance.

Trade-offs: You sacrifice some write-speed and flexible schema for absolute data correctness.

Scenario 2: E-commerce Product Catalog
Recommended Storage Type: Document Store (e.g., MongoDB, Couchbase)

Justification:

Data Structure: Products have vastly different attributes (a laptop has "RAM," but a shirt has "Fabric"). A polymorphic/schema-less JSON-like structure is ideal.

Query Patterns: Fast lookups by Product ID or Category.

Consistency: "Eventual consistency" is usually acceptable here; if a price update takes 2 seconds to propagate to all users, the system won't crash.

Scalability: Document stores excel at handling high read traffic through caching and horizontal sharding.

Trade-offs: Complex joins across different collections are difficult and should be avoided in the application logic.

Scenario 3: Telecom Call Detail Records (CDR)
Recommended Storage Type: Wide-Column Store (e.g., Apache Cassandra, ScyllaDB)

Justification:

Data Structure: Records are tied to a partition key (like Phone Number or Date) and have many attributes.

Query Patterns: Massive write-heavy workloads. These systems are optimized for high-velocity writes and time-range queries (e.g., "all calls for User X in June").

Consistency: Tunable consistency; usually configured for high availability.

Scalability: Designed to scale to petabytes across multiple data centers without a single point of failure.

Trade-offs: "Read-before-write" is slow, and queries that don't use the partition key are extremely inefficient.

Scenario 4: Social Network Relationship Graph
Recommended Storage Type: Graph Database (e.g., Neo4j, Amazon Neptune)

Justification:

Data Structure: Focuses on nodes (users) and edges (relationships like "follows" or "blocked").

Query Patterns: Excellent for "traversal" queries. Finding "friends of friends" in an RDBMS requires expensive recursive joins; in a Graph DB, itâ€™s a simple pointer hop.

Consistency: Usually ACID compliant for the graph structure.

Scalability: Designed to handle billions of connections and find the shortest path between any two points instantly.

Trade-offs: Not efficient for bulk data processing or simple list-based queries; it is specialized for connectivity.

Scenario 5: IoT Sensor Data Ingestion
Recommended Storage Type: Wide-Column Store / Time-Series Database (e.g., InfluxDB, Cassandra)

Justification:

Data Structure: Simple, append-only logs consisting of a timestamp, sensor ID, and a value.

Query Patterns: Heavy ingestion (writes) with analytical queries focusing on time intervals (averages, peaks over the last hour).

Consistency: High availability is prioritized over strict consistency (if one sensor reading is delayed, the dashboard is still useful).

Scalability: Must handle millions of events per second. Wide-column stores are perfect for this "log-style" data.

Trade-offs: Deleting or updating specific old records is often difficult or slow, as the system is optimized for appending new data.

Scenario,Recommended DB,Top Priority
1. Banking,RDBMS,ACID / Consistency
2. E-commerce,Document,Schema Flexibility
3. Telecom CDR,Wide-Column,Write Throughput
4. Social Graph,Graph,Relationship Traversal
5. IoT Sensors,Wide-Column,Time-Series Ingestion

'''