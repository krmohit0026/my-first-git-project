# -*- coding: utf-8 -*-
"""RDBMS vs NoSQL Decision Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1s4CYv1Shf6nwGpWlWD1He3XJSbeUwk00
"""

'''
Document characteristics of:

Document stores

Key-Value stores

Wide-column databases

Graph databases

ANS - While SQL databases are built on rigid tables and relationships, NoSQL (Not Only SQL) databases are designed for speed, massive scale, and flexible data models. They are the go-to choice when your data is messy, changes rapidly, or needs to be distributed across thousands of servers.

1. Document Stores
Document stores treat data as a collection of "documents" (usually in JSON or BSON format). Unlike SQL, every "row" in a Document store can have different columns.

What they are: Databases that store semi-structured data where each record contains its own schema.

Key Characteristics: Flexible (no pre-defined schema), hierarchical (you can nest arrays and objects), and easy for developers to map to their application code.

Use Cases: Content management systems, e-commerce product catalogs (where different items have different attributes), and user profiles.

Examples: MongoDB, CouchDB.

2. Key-Value Stores
This is the simplest type of NoSQL database. It acts like a giant dictionary or "Map."

What they are: Databases that store data as a simple pair: a unique Key and an associated Value.

Key Characteristics: Extreme speed (often stored in RAM), high scalability, and limited querying ability (you can usually only search by the Key).

Use Cases: Caching (storing temporary data to speed up websites), session management (keeping users logged in), and real-time leaderboards.

Examples: Redis, Amazon DynamoDB.

3. Wide-Column Databases
Think of this as a "two-dimensional" Key-Value store. It is designed to handle billions of rows across multiple servers.

What they are: Databases that store data in "column families" rather than rows. Data for a specific column is stored together on the disk.

Key Characteristics: High availability, no single point of failure, and extremely efficient for writing massive amounts of data.

Use Cases: IoT sensor data, time-series data, and large-scale web analytics where you are constantly logging events.

Examples: Apache Cassandra, HBase.

4. Graph Databases
Graph databases focus on the relationships between data points rather than the data points themselves.

What they are: Databases that use "Nodes" (entities), "Edges" (relationships), and "Properties" to represent data.

Key Characteristics: Optimized for traversing complex connections. In SQL, finding a "friend of a friend" requires complex joins; in a Graph DB, it is a simple path-follow.

Use Cases: Social networks, fraud detection (finding clusters of related suspicious accounts), and recommendation engines ("People who bought this also bought...").

Examples: Neo4j, Amazon Neptune.

'''

'''
Explain:

ACID properties with examples

BASE properties with examples

Why BASE is acceptable in some systems

ANS - In the world of data, there is a fundamental trade-off between guaranteed accuracy and massive scale. This conflict is represented by two different design philosophies: ACID (the standard for SQL) and BASE (the standard for NoSQL).

1. ACID: The Standard for Absolute Reliability
ACID properties ensure that every database transaction is processed reliably. This is the "strict" approach.

Atomicity ("All or Nothing"): A transaction is treated as a single unit. If any part of the transaction fails, the entire thing is canceled (rolled back).

Example: If you transfer $100 from Savings to Checking, Atomicity ensures that the money isn't "lost" if the system crashes after it leaves Savings but before it hits Checking.

Consistency: The database must move from one valid state to another, following all predefined rules (constraints).

Example: If a database rule says "Balance cannot be negative," a transaction that tries to withdraw $500 from a $200 account will be rejected.

Isolation: Transactions happening at the same time do not interfere with each other. It looks as if they are running one after the other.

Example: If two people try to buy the last concert ticket at the exact same millisecond, Isolation ensures only one succeeds and the other sees "Sold Out."

Durability: Once a transaction is committed, it is permanentâ€”even if the power goes out or the system crashes.

Example: Once you receive a "Payment Successful" screen, that record is written to a non-volatile disk, not just stored in temporary memory.

When ACID is Critical: Financial systems, healthcare records, and inventory management.

2. BASE: The Standard for Speed and Scale
BASE properties prioritize availability and performance over immediate consistency. This is the "relaxed" approach.

Basically Available: The system guarantees a response to every request, but it might not be the most "up-to-date" data. The system stays up even if parts of it fail.

Soft State: The state of the system may change over time, even without new input, as data is copied between different servers.

Eventual Consistency: The system will eventually become consistent across all servers, but it may take a few seconds (or minutes) for a change made in New York to show up for a user in London.

Example: When you post a photo on Instagram, your friend in the next room might see it immediately, but your friend in another country might not see it for 30 seconds.

3. Why BASE is Acceptable
In massive systems, ACID is often impossible because the overhead of "locking" millions of records to ensure 100% accuracy would make the website too slow to use.

Scenarios where Eventual Consistency is fine:
Social Media: It doesn't matter if your "Like" count is off by 2 for a few seconds.

Collaborative Editing: In Google Docs, you see updates from others "eventually" as the sync happens.

Product Reviews: If a new 5-star review takes a minute to appear globally, it has zero impact on the business.
'''

'''
RDBMS vs NoSQL Comparison

Create a comparison table for:

Consistency
Scalability
Query flexibility
Schema rigidity

ANS - Choosing between an RDBMS (Relational) and NoSQL depends entirely on the nature of your data and the requirements of your application.
While RDBMS prioritizes order and accuracy, NoSQL prioritizes agility and growth.

Understanding the Trade-offs
1. The Scaling Wall
In an RDBMS, once your single server is the fastest it can possibly be, you hit a "wall." Scaling NoSQL is like adding more lanes to a highway; scaling RDBMS is like trying to build a faster car.

2. The Schema Struggle
In an RDBMS, if you want to add a "Middle Name" field to a table with 100 million rows, the database might lock up for hours while it updates every record. In a NoSQL document store, you just start including "Middle Name" in your new JSON files, and the database doesn't mind at all.

3. The Query Complexity
If you need to join 5 tables (Customers, Orders, Items, Shipping, Payments) to find out who bought a specific shoe in London, SQL handles this natively. In most NoSQL systems, you would have to write complex application code to stitch that data together manually.

Which should you choose?
Choose RDBMS if: You are building a banking app, an ERP, or any system where data integrity is more important than massive speed (e.g., your "sensor_file_demo" project).

Choose NoSQL if: You are building a real-time messaging app, an IoT sensor logger, or a content feed where the data structure changes every week and you expect millions of users.

Feature,RDBMS (SQL),NoSQL,Trade-offs
Consistency,Immediate Consistency: Uses ACID properties to ensure data is 100% accurate at all times across all nodes.,Eventual Consistency: Often uses BASE properties; data may take time to sync across all servers.,ACID is safer for money/health; BASE is better for high-speed apps like social media.
Scalability,"Vertical (Scale-Up): Requires adding more power (CPU/RAM) to a single, increasingly expensive server.","Horizontal (Scale-Out): Adds more cheap servers to a cluster, distributing the load across many nodes.",Vertical is limited by hardware ceilings; Horizontal is virtually limitless but harder to manage.
Query Flexibility,High: SQL allows complex joins and ad-hoc queries. You can ask almost any question of your data.,Low to Moderate: Optimized for specific access patterns. Complex joins are often impossible or very slow.,"RDBMS is better for ""discovery"" and analytics; NoSQL is better for predictable, high-speed data retrieval."
Schema Rigidity,Rigid: Requires a pre-defined schema. You must define columns before inserting data. Changes are slow.,Flexible: Dynamic schema. Different rows can have different fields. Perfect for unstructured data.,"Rigid prevents data ""garbage""; Flexible allows for rapid development and changing requirements."
'''

'''
Scenario Decisions



Decide which storage type fits best for each scenario and justify:

Banking system

E-commerce platform

Telecom call data records (CDR)

ANS - Selecting the right database isn't about finding the "best" technology, but the "best fit" for the specific data behavior. Here is how you should categorize these three distinct scenarios.

1. Banking System
Recommended Storage Type: RDBMS (SQL) (e.g., PostgreSQL, Oracle)

Data Structure Requirements: Extremely structured. Every account, transaction, and user profile must follow strict rules (e.g., a "Balance" must be a decimal).

Consistency Needs: ACID Compliance is non-negotiable. If a transfer happens, the withdrawal and deposit must succeed together or fail together. Eventual consistency is not an option when money is moving.

Query Patterns: Complex. Banks need to run intricate reports, join customer data with loan history, and perform audits across many related tables.

Scalability Requirements: Primarily Vertical. While banks have many users, the priority is the integrity of the individual transaction rather than millions of simultaneous social media updates.

2. E-Commerce Platform
Recommended Storage Type: Hybrid (Polyglot Persistence)

Primary Store: Document Store (NoSQL) (e.g., MongoDB) for Product Catalogs.

Transactional Store: RDBMS for Orders/Payments.

Data Structure Requirements: Highly variable. A "Laptop" has a CPU and RAM, but a "Shirt" has a size and material. A NoSQL document store handles these differing attributes effortlessly.

Consistency Needs: BASE / Eventual Consistency is acceptable for product views and inventory (it's okay if a "Low Stock" warning is slightly delayed). However, the checkout process still needs ACID (RDBMS).

Query Patterns: Simple lookups (finding a product by ID) mixed with search filters (filtering by color, price, and brand).

Scalability Requirements: High Horizontal scalability. E-commerce sites face massive traffic spikes (like Black Friday) and need to add servers quickly.

3. Telecom Call Data Records (CDR)
Recommended Storage Type: Wide-Column Store (e.g., Apache Cassandra)

Data Structure Requirements: Semi-structured but consistent. Every call generates a record with a start time, end time, caller ID, and duration.

Consistency Needs: Eventual Consistency. If a call record takes 2 seconds to replicate across global servers, it doesn't affect the phone call or the billing accuracy in the long run.

Query Patterns: High-volume writes and time-based queries. Telecoms generate billions of records a day; the database must be able to "ingest" this data without slowing down.

Scalability Requirements: Massive Horizontal scalability. Data is often partitioned by phone number or date to distribute the load across hundreds of servers.
'''